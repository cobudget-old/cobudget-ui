var Decimal = require('decimal');
var Moment = require('moment');
var _ = require('lodash');

var sum = require('utils/sum');

/* @ngInject */
module.exports = function (AuthService, BaseModel, BaseCollection, AllocationModel, BucketModel, FixedCostModel) {
  return BaseModel.extend({
    modelType: 'Round',

    props: {
      name: 'string',
      groupId: 'number',

      startsAt: 'moment',
      endsAt: 'moment',

      membersCanProposeBuckets: {
        type: 'boolean',
        'default': false,
      },
    },

    collections: {
      allocations: BaseCollection.extend({
        model: AllocationModel,
      }),
      buckets: BaseCollection.extend({
        model: BucketModel,
      }),
      fixedCosts: BaseCollection.extend({
        model: FixedCostModel,
      }),
    },

    initialize: function () {
      // listen to allocations events
      this.listenTo(this.allocations, 'all',
        this._getEventBubblingHandler(this.allocations)
      );
      // listen to buckets events
      this.listenTo(this.buckets, 'all',
        this._getEventBubblingHandler(this.buckets)
      );
      // listen to fixedCosts events
      this.listenTo(this.fixedCosts, 'all',
        this._getEventBubblingHandler(this.fixedCosts)
      );
    },

    derived: {
      status: {
        deps: ['startsAt, endsAt'],
        cache: false,
        fn: function () {
          var now = Moment();
          if (this.startsAt.isAfter(now)) {
            let changeLabel = 'starts';
            let changeTime = this.startsAt.from(now);
            return {
              name: 'pending',
              'class': 'info',
              label: changeLabel + ' ' + changeTime,
              changeLabel: changeLabel,
              changeTime: changeTime,
            };
          } else if (
            this.startsAt.isBefore(now) &&
            this.endsAt.isAfter(now)
          ) {
            return {
              name: 'open',
              'class': 'success',
              label: 'open now, ends ' + this.endsAt.from(now),
              changeLabel: 'time left',
              changeTime: this.endsAt.from(now, true),
            };
          } else {
            let changeLabel = 'ended';
            let changeTime = this.endsAt.from(now);
            return {
              name: 'closed',
              'class': 'warning',
              label: changeLabel + ' ' + changeTime,
              changeLabel: changeLabel,
              changeTime: changeTime,
            };
          }
        },
      },
      myContributions: {
        deps: ['buckets'],
        cache: false,
        fn: function () {
          return this.buckets.pluck('myContribution');
        },
      },

      myAllocationIndex: {
        deps: ['allocations'],
        cache: false,
        fn: function () {
          var currentUser = AuthService.getCurrentUser();
          return this.allocations.findIndex(function (allocation) {
            return allocation.userId === currentUser.id;
          });
        },
      },

      myAllocation: {
        deps: ['myAllocationIndex', 'allocations'],
        cache: false,
        fn: function () {
          var index = this.myAllocationIndex;
          if (index !== -1) {
            return this.allocations.models[index];
          } else {
            return new AllocationModel({
              userId: AuthService.getCurrentUser().id,
              roundId: this.id,
              amount: 0,
            });
          }
        },
      },

      groupAllocations: {
        deps: ['allocations'],
        cache: false,
        fn: function () {
          var currentUser = AuthService.getCurrentUser();
          return this.allocations.filter(function (allocation) {
            return allocation.user.id !== currentUser.id;
          });
        },
      },

      allocationsTotal: {
        deps: ['allocations'],
        cache: false,
        fn: function () {
          return sum(this.allocations.pluck('amount'));
        },
      },
      myContributionsTotal: {
        deps: ['myContributions'],
        cache: false,
        fn: function () {
          return sum(_.pluck(this.myContributions, 'amount'));
        },
      },
      myAllocationAmount: {
        deps: ['myAllocation'],
        cache: false,
        fn: function () {
          return this.myAllocation.amount;
        },
      },
      myAllocationLeft: {
        deps: ['myAllocationAmount', 'myContributionsTotal'],
        cache: false,
        fn: function () {
          return this.myAllocationAmount.minus(this.myContributionsTotal);
        },
      },
      totalAllocated: {
        deps: ['buckets'],
        cache: false,
        fn: function () {
          return sum(this.buckets.pluck('contributionTotal'));
        },
      },
      totalAllocable: {
        deps: ['allocations'],
        cache: false,
        fn: function () {
          return sum(this.allocations.pluck('amount'));
        },
      },
      fixedCostTotal: {
        deps: ['fixedCosts'],
        cache: false,
        fn: function () {
          return sum(this.fixedCosts.pluck('amount'));
        },
      },
    },

    getAllocationsByUser: function () {
      // index allocations by user id
      var allocationsByUserId = {};

      this.allocations.forEach(function (allocation) {
        allocationsByUserId[allocation.userId] = allocation;
      });

      return allocationsByUserId;
    },

    getContributors: function (memberships) {
      var contributors = {};

      var allocationsByUserId = this.getAllocationsByUser();

      // for each member
      memberships.forEach(function (membership) {
        var contributor = {
          user: membership.member,
        };

        var allocation = allocationsByUserId[contributor.user.id];

        if (allocation) {
          contributor.allocation = allocation.amount;
        } else {
          contributor.allocation = new Decimal(0);
        }

        contributors[contributor.user.id] = contributor;
      });

      // for each bucket
      this.buckets.forEach(function (bucket) {
        var contributions = bucket.getContributionsByUser();

        // add contributions to contributors
        _.each(contributions, function (contribution, userId) {
          var contributor = contributors[userId];

          if (!contributor) { return; }

          if (!contributor.contribution) {
            contributor.contribution = contribution.amount;
          } else {
            contributor.contribution = contributor.contribution.plus(contribution.amount);
          }
        });
      });

      return contributors;
    },
  });
};
